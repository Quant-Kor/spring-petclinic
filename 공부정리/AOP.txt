AOP(관심사 oriented) - 관점 지향
흩어진 코드를 한곳으로 모아


class A {
	method a () {
		AAAA
		mesagge....
		BBBBB
	}

	method b () {
		AAAA
		mesageg...
		BBBB
	}
}

class B {
	method c() {
		AAAA
		message,,,
		BBBB
	}
}

class A {
	method a () {
		
		mesagge....
		
	}

	method b () {
		
		mesageg...
		
	}
}

class B {
	method c() {
		
		message,,,
		
	}
}

class AAAABBBB {
	method aaaabbbb(JoinPoint point) {
		AAAA
		point.execute()
		BBBB
	}
}

다양한 AOP 구현 방법
 - 컴파일           A.java ------(AOP) ----> A.class (AspectJ) 자바파일에는 없는데 클래스로 컴파일 되면서 AOP가 중간에 코드를 넣어주는 방법

 - 바이트코드 조작       A.java -> A.class ---- (AOP) ---> 메모리 (AspectJ) (클래스가 메모리로 로딩하는 시점에서 코드가 추가됨)

 - 프록시 패턴 (스프링 AOP) 
기존의 코드를 건드리지 않고 객체를 다른 객체로 바꾸는 방법 - 클라이언트 코드에 영향을 적게줌




@Transactional 


Annotation을 사용한 AOP - @LogExecutionTime


@Component
@Aspect
public class LogAspect {

	Logger logger = LoggerFactory.getLogger(LogAspect.class);

	@Around("@annotation(LogExecutiontime)")
	public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {
		StopWatch stopWatch = new StopWatch();
		stopWatch.start();

		Object proceed = joinPoint.proceed();

		stopWatch.stop();
		logger.info(stopWatch.prettyPrint());

		return proceed;

	}
}
